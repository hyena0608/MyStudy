# 1주차 : 문자열 계산기
#넥스트스텝/자바플레이그라운드/문자열계산기

아래 링크는 미션을 수행한 실제 코드가 모여 있는 레포입니다.

[GitHub - hyena0608/java-baseball-playground at hyunseo](https://github.com/hyena0608/java-baseball-playground/tree/hyunseo)

<br>
<br>

첫 미션으로 문자열 계산기를 구현해보았다.
간단한 사칙연산 계산기 구현은 어렵지 않고 문자열 계산기를 구현하는 부분도 어렵지 않다.
하지만 이번 미션에서 배워가야 할 것은 따로 있다.

바로 

1. 메서드 분리
2. 함수명, 변수명 생각
3. 깃 커밋 메시지
4. 단위 테스트

가 있다.

계산기를 구현하고 끝내지말고
현재 내 코드가 재사용성이나 가독성이 좋은지 즉, 클린한 코드인지를 확인해가고 다른 사람들의 구현 방식을 보며 셀프 피드백하고 고쳐나가자.

<br>
<br>
<br>


# 1-1) [1차 구현]
처음 구현 했을 때의 모양이다.
![](https://velog.velcdn.com/images/hyena0608/post/ad281604-c1c7-4a9e-9d26-7f290c380939/image.png)

StringSplitCalculatorTest를 구현했는데
StringCalculator와 단위 테스트를 위한 StringCalculatorTest로 나누어져 구현 되어있다.

- StringCalculator는 3개의 메서드로 구분 되었다.
	1. `calculateAll(String value)` : 밑의 두 메서드를 합쳐 문자열 계산기 기능을 한다.
	2. `calculateOnce(double sum, double x, String cal)`  : 하나의 계산을 하여 실수를 반환한다.
	3. `splitStringToStringArray(String value)` : 공백을 기준으로 분리하여 String 배열을 반환한다.

```java
package study;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.*;

public class StringSplitCalculatorTest {

    StringCalculator stringCalculator = new StringCalculator();

    @Test
    @DisplayName("문자열 입력 계산")
    void stringsplitCalculator() {
        //given
        String value = "2 + 3 * 4 / 2";

        //when
        double sum = stringCalculator.calculateAll(value);

        //then
        assertThat(sum).isEqualTo(10);
    }

    @Test
    @DisplayName("공백 혹은 Null 에러")
    void expressionforEmptyOrNull() {
        String value = "2 * 3 4 / 2";
        assertThatThrownBy(() -> {
            stringCalculator.calculateAll(value);
        }).isInstanceOf(NumberFormatException.class);
    }
}

class StringCalculator {

    public double calculateAll(String value) {
        String[] values = splitStringToStringArray(value);
        double sum = Double.parseDouble(values[0]);
        for (int i = 1; i < values.length; i += 2) {
            sum = calculateOnce(sum, Double.parseDouble(values[i + 1]), values[i]);
        }
        return sum;
    }

    private double calculateOnce(double sum, double x, String cal) {
        switch(cal) {
            case "+":
                return sum + x;
            case "-":
                return sum - x;
            case "*":
                return sum * x;
            case "/":
                return sum / x;
            default:
                return 0.0;
        }
    }

    private String[] splitStringToStringArray(String value) {
        return value.split(" ");
    }
}
```

<br>
<br>
<br>

# 1-2) [1차 셀프 피드백]
**셀프 피드백 내용**
1. [패키지] : Test에는 테스트 코드만 구현하라
2. [클래스 분리] : StringCalculator 한 클래스에 구현하지 말아라
3. [클래스 분리] : StringCalculator는 **유틸리티인지 객체인지** 확실하게,  
calculateOnce에서 연산 타입이 확실하지 않고 문자로만 되어 있는데 **인스턴스 변수로 선언**하라.
4. [테스트 코드] : 예외적인 입력값을 더 고민해서 추가해보아라.

<br>
<br>
<br>

## 1-2-1) 패키지
Test 클래스에 Test클래스가 아닌 다른 클래스도 존재한다.
이를 main으로 분리하여 상황에 맞는 디렉터리로 들어간다.

나는 StringSplitCalculatorTest 내에 테스트 이외의 코드를 src/main/java/calculator 디렉터리에
`Calculator.java`와 `StringCalculator.java` 로 두 클래스로 나누었다.

<img src="https://velog.velcdn.com/images/hyena0608/post/2e248e83-dc6a-4575-9230-bbab2e6d711c/image.png" width="400">


<br>
<br>
<br>

## 1-2-2) 클래스 분리 (1)
간단하게 사칙연산 계산기를 만드는 거라고 생각해서 클래스를 분리할 생각을 하지 못했다.
분리를 한다면 어떤 식으로 분리 해야할 지 감이 잡히지 않는데 평소에 클래스를 분리한다고 하면 의미를 기준으로 나누었기 때문이다.

이를 해결하기 위해서 아래와 같은 책, 블로그 포스팅을 읽었다.

- [책정보, 객체지향의 사실과 오해 : 네이버 책](https://book.naver.com/bookdb/book_detail.nhn?bid=9145968)
- [객체지향 프로그래밍으로 유틸리티 클래스를 대체하자. | Mimul Tech log](https://www.mimul.com/blog/oop-alternative-to-utility-classes/) 

<br>
<br>
<br>

## 1-2-3) 클래스 분리 (2)
내가 만드는 Calculator는 절차적 프로그래밍이 아닌 즉, 유틸리티 클래스가 아니라 객체로 만들 것이다.

먼저 Calculator.java를 보면
```java
package calculator;

public class Calculator {

    public static double caculateOnce(double num1, double num2, String operator) {
        switch(operator) {
            case "+":
                return num1 + num2;
            case "-":
                return num1 - num2;
            case "*":
                return num1 * num2;
            case "/":
                return num1 / num2;
            default:
                return 0.0;
        }
    }
}
```

> 위와 같이 switch문으로 사칙연산이 구분되어 지는데  
> switch문을 사용하지 않고 다른 더 객체지향적인 방법을 사용하라.   
> 즉, operator를 객체화 시켜보자.  

위에서 클래스를 두 개로 분리한 것으로 끝난 것이 아니다. 
좀 더 자세히 들여다 보면 더 클래스로 분리시켜 객체지향적으로 구현할 수 있는 부분들을 객체화 시키라는 말이다.

# 2-1) [2차 구현]

2차 구현을 위해서 두 가지 공부를 했다.

- Enum (열거형)
- 람다와 스트림
- java.util.function 패키지

위에 1차 피드백을 받고 해결하기 위해 필요한 부분만 공부하고 깃허브에 정리했다.

[깃허브 정리 - Enum (열거형)](https://github.com/hyena0608/MyStudy/blob/master/%EC%9E%90%EB%B0%94/%5B%EC%9E%90%EB%B0%94%5D_%EC%97%B4%EA%B1%B0%ED%98%95_(13).md)
[깃허브 정리 - 람다와 스트림 (+ java.util.function)](https://github.com/hyena0608/MyStudy/blob/master/%EC%9E%90%EB%B0%94/%5B%EC%9E%90%EB%B0%94%5D_%EB%9E%8C%EB%8B%A4%EC%99%80_%EC%8A%A4%ED%8A%B8%EB%A6%BC_(14).md)

---

## 2-1-1) switch문 대신 Enum 사용하기

이제 아래와 같이 문자열 계산기가 개선되었다.

먼저 ***Enum Operator***로 이전에 switch문을 없앴다.

Enum을 사용한 이유 ??

- 서로 관련된 상수를 더 편하게 선언할 수 있고
- switch를 사용할 때보다 오류 발생 가능성을 줄일 수 있기 때문에 사용했다.

<br>

기존에 Calculator.java가 삭제되고 Operator.java를 생성했다.
그리고 Enum으로 아래와 같이 구현하였다.

- 상수 PLUS, MINUS, MULTIPLY, DIVIDE를 선언하고 
또한 StringCalculator에서 문자열을 split하여 계산할 때 나오는 연산자 symbol을 통해서 구분할 것이기에 상수의 값을 `+, -, * /`를 각각 추가하였다.

- 연산자를 받기 위한 문자열 `symbol` 선언

- 계산을 할 때 들어올 값 두 매개변수와 반환할 결과 값 매개변수 하나를 선언하기 위해 java.util.function 패키지에 `BiFunction`으로 선언했다.

- Enum 클래스에 추상 메서드를 선언해서 각각 상수를 통해 메서드를 람다형식으로 구현했다.

- `findOperator(String symbol)` 은 들어온 인자 값을 통해 operatorMap에서 나온 반환값 Map에서 get()으로 선언된 상수값을 통해 값에 맞는 상수가 들어간 Operator 클래스의 인스턴스를 반환한다.

- `operatorMap`은 스트림을 통해 Enum 내부 메서드인 `values()`로 상수들을 받아 `Stream.of`로 스트림 형식으로 만들어 최종 연산인 `collect()`를 이용해 한 객체마다 갖고 있는 symbol을 key로 Operator클래스의 인스턴스를 value로 넣어 Map으로 묶어 반환한다.

- `operate(double first, double second)` 메서드가 있는데 내부를 보면 `operation.apply(first, second);` 로 apply 메서드를 호출한다.
이 때 `apply()`는 BiFunction 함수형 인터페이스의 내부 메서드로 위에 추상 메서드를 구현한 메서드가 호출 된다.

```java
package calculator;

import javax.swing.*;
import java.util.Collections;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public enum Operator {
    PLUS("+", (first, second) -> first + second),
    MINUS("-", (first, second) -> first - second),
    MULTIPLY("*", (first, second) -> first * second),
    DIVIDE("/", (first, second) -> {
        if (second == 0) throw new IllegalArgumentException();
        return first / second;
    });

    private String symbol;
    private BiFunction<Double, Double, Double> operation;

    Operator(String symbol, BiFunction<Double, Double, Double> operation) {
        this.symbol = symbol;
        this.operation = operation;
    }

    public String getSymbol() {
        return this.symbol;
    }

    public double operate(double first, double second) {
        return operation.apply(first, second);
    }

    private static final Map<String, Operator> operatorMap =
            Collections.unmodifiableMap(Stream.of(values())
                    .collect(Collectors.toMap(operator -> operator.getSymbol(), 
                                                operator -> operator)));

    public static Operator findOperator(String symbol) {

        Operator operator = operatorMap.get(symbol);

        if (operator == null) {
            throw new IllegalArgumentException();
        }
        return operator;
    }
}
```

Enum 클래스를 만듬으로서 StringCalculator.java 내부도 살짝 변경이 되었다.
함수랑 변수명을 조금 바꿔주었다.

```java
package calculator;

public class StringCalculator {

    public double calculate(String str) {
        String[] strArr = splitBySpace(str);
        double value = Double.parseDouble(strArr[0]);
        for (int i = 1; i < strArr.length; i += 2) {
            value = Operator.findOperator(strArr[i]).operate(value, Double.parseDouble(strArr[i + 1]));
        }
        return value;
    }

    private String[] splitBySpace(String value) {
        return value.split(" ");
    }
}
```

---

## 2-1-2) 테스트 코드의 추가

다음은 테스트 코드의 추가이다.

처음에 테스트 코드를 문제에서 말해준 한 두가지만 구현하고 끝냈는데

테스트 코드는 많으면 많을 수록 좋은거니까.. 일단 생각나는 것들을 최대한 테스트 코드로 작성했다.

작성한 테스트 코드는 아래와 같다.

```java
package study;

import calculator.StringCalculator;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.*;

public class StringSplitCalculatorTest {

    StringCalculator stringCalculator = new StringCalculator();

    @Test
    @DisplayName("더하기 연산 테스트")
    void plusTest() {
        // given
        String str = "3 + 2";

        // when
        double value = stringCalculator.calculate(str);

        // then
        Assertions.assertThat(value).isEqualTo(5);
    }

    @Test
    @DisplayName("빼기 연산 테스트")
    void minusTest() {
        // given
        String str = "3 - 2";

        // when
        double value = stringCalculator.calculate(str);

        // then
        Assertions.assertThat(value).isEqualTo(1);
    }

    @Test
    @DisplayName("곱하기 연산 테스트")
    void multiplicationTest() {
        // given
        String str = "3 * 2";

        // when
        double value = stringCalculator.calculate(str);

        // then
        Assertions.assertThat(value).isEqualTo(6);
    }

    @Test
    @DisplayName("나누기 연산 테스트")
    void divideTest() {
        // given
        String str = "3 / 2";

        // when
        double value = stringCalculator.calculate(str);

        // then
        Assertions.assertThat(value).isEqualTo(1.5);
    }

    @Test
    @DisplayName("종합 계산 테스트")
    void totalCalculationTest() {
        // given
        String str = "2 + 3 * 4 / 2";

        // when
        double value = stringCalculator.calculate(str);

        // then
        assertThat(value).isEqualTo(10);
    }

    @Test
    @DisplayName("연산자 두 번 이상 반복시 IllegalArgumentException 예외 테스트")
    void operatorExceptionTest() {
        Assertions.assertThatThrownBy(() -> {
            // given
            String str = "3 + + 2";

            // when
            stringCalculator.calculate(str);

            // then
        }).isInstanceOf(IllegalArgumentException.class);

    }

    @Test
    @DisplayName("피연산자 두 번 이상 반복시 IllegalArgumentException 예외 테스트")
    void operandExceptionTest() {
        Assertions.assertThatThrownBy(() -> {
            // given
            String str = "3 2 + 2";

            // when
            stringCalculator.calculate(str);

            // then
        }).isInstanceOf(IllegalArgumentException.class);

    }

    @Test
    @DisplayName("공백 두 번 이상 반복시 IllegalArgumentException 예외 테스트")
    void spaceExceptionTest() {
        Assertions.assertThatThrownBy(() -> {
            // given
            String str = "3  + 2";

            // when
            stringCalculator.calculate(str);

            // then
        }).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    @DisplayName("0으로 나눌시 IllegalArgumentException 예외 테스트")
    void divideByZeoExceptionTest() {
        Assertions.assertThatThrownBy(() -> {
            // given
            String str = "3 / 0";

            // when
            stringCalculator.calculate(str);

            // then
        }).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    @DisplayName("사칙연산이 아닐 시 IllegalArgumentException 예외 테스트")
    void notOperatorExceptionTest() {
        Assertions.assertThatThrownBy(() -> {
            // given
            String str = "3 # 2";

            // whe
            stringCalculator.calculate(str);

            // then
        }).isInstanceOf(IllegalArgumentException.class);
    }
}
```

위와 같이 피드백을 토대로 재구현하면서 아래 내용을 배울 수 있었다.

1. 람다의 메서드 간편화와 

2. 스트림이 중간연산과 최종연산으로 이루어지고 중간 연산일 때는 스트림 타입이며 내부 반복이 강력한 무기임을 배웠다.

3. 또한 Enum을 사용할 때 상수만 선언해서 다른 클래스에서 불러와 사용했는데
추상 메서드를 선언해서 각 객체인 상수마다 메서드를 구현할 수 있었고, 
상수를 구분할 때 Enum 클래스 내부에서 구별 메서드를 구현해서 Enum의 장점을 더욱 잘 사용하게 되었다.

---

# 2-2) [2차 셀프 피드백]
**셀프 피드백 내용**
1. [책임 분리] : StringCalculator 내에 split과 calculate를 분리하라.
2. [기능 추가] : StringCalculator 내에서 문자와 숫자를 구분할 때 정규표현식를 사용해보라


## 2-2-1) 책임 분리

아래 StringCalculator 클래스를 보면 두가지 메서드가 있다.
문자열을 split하는 기능을 가진 `splitBySpace(String)` 메서드와 나눠진 문자열을 각각 계산에서 최종 결과값을 만드는 `calculate(String)`이 있다.

생각해보자. 
왜 책임 분리를 할 수 있을까?

먼저 **객체지향 개발 5대 원리 SOLID**에 대해서 왜 필요하고 어떻게 하는지 알아야 한다.
필자는 아래 링크를 참고하여 공부하여 현재 클래스에 어떤 문제가 있는지 알 수 있었다.
- https://www.nextree.co.kr/p6960/

필자가 생각한 문제는 이와 같다.


```java
package calculator;

public class StringCalculator {

    public double calculate(String str) {
        String[] strArr = splitBySpace(str);
        double value = Double.parseDouble(strArr[0]);
        for (int i = 1; i < strArr.length; i += 2) {
            value = Operator.findOperator(strArr[i]).operate(value, Double.parseDouble(strArr[i + 1]));
        }
        return value;
    }

    private String[] splitBySpace(String value) {
        return value.split(" ");
    }
}
```

