- [1. 상속 🚀](#1-상속-🚀)
  * [1-1. 상속의 정의](#1-1-상속의-정의)
  * [1-2. 단일 상속 (single inheritance)](#1-2-단일-상속-single-inheritance)
  * [1-3. 클래스간의 관계 - 포함관계](#1-3-클래스간의-관계---포함관계)
  * [1-4. 클래스간의 관계 결정 (상속관계, 포함관계)](#1-4-클래스간의-관계-결정-상속관계-포함관계)
  * [1-5. Deck-Card 관계 예제](#1-5-deck-card-관계-예제)

<br>
<br>
<br>

# 1. 상속 🚀

<br>

상속하면 먼저 부모클래스, 자식클래스, `extends` 정도가 기억난다.

자주 사용해보지는 못했지만 있는 것도 알고 어떻게 쓰이는 줄 안다.

<br>

부모가 가진 능력을 자식이 가지고 있고 자식은 개인적인 능력도 가지고 있다.

간단하게 설명하자면 이렇다. 부모-자식 관계를 우리는 '상속 관계'라고 한다.

<br>

이런 상속을 통해 우리는 객체지향적인 코드를 설계할 수 있다.

<br>

이번에 목표는 상속 예제를 만들면서 상속이 무서워 보이지 않게 하려한다.

정의부터 시작해서 알아보자 !

<br>
<br>
<br>

## 1-1. 상속의 정의

<br>

***상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것***

<br>

우리 상속을 사용하는 이유는 뭘까 ??

상속은 코드의 중복을 제거하여 생산성과 유지보수에 좋다.

<br>

눈으로 직접 보기 위해서는 예시를 봐야한다.

먼저 기본 틀을 보자.

<br>

상속 예시 코드

- 자식 클래스의 인스턴스를 생성하면 부모 클래스의 멤버도 함께 생성된다.
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 접근 제어자가 `private` 또는 `default`일 경우 자식 클래스한테 상속은 되지만 접근은 불가하므로 사용이 안된다. 

```java
class DogParent {
    String name;
    int age;

    void jump() {
        System.out.println("점프해버리기 ~");
    } 
} 

class DogChild extends Parent {
    int age;
}

class DogChildTest {
    public static void main(String args[]) {

        DogChild dc = new DogChild();
        dc.name = "복팔치";
        dc.age = 7;
        dc.jump();
    }
}
```

<br>
<br>
<br>

## 1-2. 단일 상속 (single inheritance)

<br>

***자바에서는 오직 단일 상속만 가능하다.***

<br>

밑에는 잘못된 상속이다.

```java
// 잘못된 상속, 에러 발생
// 단일 상속만 가능하다.
class TVCR extends TV, VCR {
    // 에러
}
```

<br>
<br>
<br>

## 1-3. 클래스간의 관계 - 포함관계

<br>

포함관계 ??

***포함관계는 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 의미한다.***

<br>

말이 어려울 수도 있는데 코드를 보면 바로 느낌이 올 것이다.

Circle클래스 안에 Point 타입의 참조변수가 멤버변수로 온 것이다.

```java
class Point {
    int x;
    int y;
}

class Circle {
    Point c = new Point();
    int r;
}
```

이런 식으로 상속관계 이외에 클래스를 재사용하는 또 다른 방법이 **포함관계**이다.

우리는 클래스 간에 포함관계를 여태껏 많이 사용해왔다.

상속관계와 마찬가지로 재사용하면 보다 더 손쉽게 클래스를 만들 수 있는데 어떤거르 사용하는게 좋을까 ??

구별하는 법이 있긴하지만 완벽하지 않은 방법을 소개하겠다.

<br>
<br>

## 1-4. 클래스간의 관계 결정 (상속관계, 포함관계)

<br>

상속관계와 포함관계 어떻게 다를까?

간단하게 파악하기에는 **문맥**을 보면된다.

바로 예시를 봐보자.

```java
// 포함관계
class DogChild {
    DogParent dp = new DogParent();
}
```

```java
// 상속관계
class DogChild extends DogParent {
}
```

두 뜻은 아예 달라진다.

*포함관계* : 자식강아지(DogChild)는 부모강아지(DogParent)이다.

*상속관계* : 자식강아지(DogChild)는 부모강아지(DogParent)를 가지고 있다.


포함 관계를 보면 자식강아지는 부모강아지가 아니고 자식강아지는 부모강아지의 능력을 내포하고 있음으로 상속관계임을 알 수 있다.

너무 간단한 예제였기 때문에 이번에는 ***Deck-Card*** 관계 예제를 들여다보자 !!

<br>
<br>
<br>


## 1-5. Deck-Card 관계 예제

<br>

Card클래스를 재사용하여 Deck클래스와 포함관계로 작성한다.

Deck클래스의 인스턴스를 생성할 때 인자가 없는 기본생성자를 택한다.

이 때 52장의 카드가 만들어 집니다.

`Card클래스의 인스턴스 주소를 저장해줄 참조변수 c`에 `Deck클래스의 인스턴스의 참조변수인 d`를 통해서 Deck클래스의 pick(int index)를 불러온다. 

이 때 반환타입은 Card이므로 `Card클래스의 인스턴스 참조변수 c`에 주소를 넣어준다. 

`System.out.println(c)`이 실행된다.

이후 생략..

```java
class DeckTest {
    public static void main(String[] args) {
        Deck d = new Deck();    // 카드 한 벌(Deck)을 만든다.
        Card c = d.pick(0);     // 섞기 전에 제일 위의 카드 뽑기
        System.out.println(c);  // c는 c.toString()과 같다.

        d.shuffle();            // 카드를 섞는다.
        c = d.pick(0);          // 섞은 후에 제일 위의 카드 뽑기
        System.out.println(c);
    }
}

class Deck {
    final int CARD_NUM = 52;
    Card[] cardArr = new Card[CARD_NUM]; // 포함 관계

    Deck() {
        int i = 0;

        for (int k = Card.KIND_MAX; k > 0; k--) {
            for (int n = 0; n < Card.NUM_MAX; n++) {
                cardArr[i++] = new Card(k, n + 1);
            }
        }
    }

    Card pick(int index) {
        return cardArr[index];
    }

    Card pick() {
        int index = (int) (Math.random() * CARD_NUM);
        return pick(index);
    }

    void shuffle() {
        for (int i = 0; i < cardArr.length; i++) {
            int r = (int) (Math.random() * CARD_NUM);

            Card temp = cardArr[i];
            cardArr[i] = cardArr[r];
            cardArr[r] = temp;
        }
    }
}

class Card {
    static final int KIND_MAX = 4;
    static final int NUM_MAX = 13;

    static final int SPADE = 4;
    static final int DIAMOND = 3;
    static final int HEART = 2;
    static final int CLOVER = 1;
    int kind;
    int number;

    Card() {
        this(SPADE, 1);
    }

    Card(int kind, int number) {
        this.kind = kind;
        this.number = number;
    }

    public String toString() {
        String[] kinds = {"", "CLOVER", "HEART", "DIAMOND", "SPADE"};
        String numbers = "0123456789XJQK";
        return "kind : " + kinds[this.kind] + ", number : " + numbers.charAt(this. number);
    }
}
```

<br>
<br>
<br>

위에서 두 가지의 클래스를 만들었는데 이는 **포함관계를 가지고 있는 예제**였다.

Deck클래스, Card클래스를 보면서 객체가 어떤 식으로 관계를 맺는지 경험할 수 있었다.

**상속관계**도 자주 쓰이지만 **포함관계**도 매우 자주 쓰는 중요한 유형들이다.

