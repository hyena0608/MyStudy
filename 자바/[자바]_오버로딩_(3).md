- [3. 오버로딩 (overloading) 🚀](#3-오버로딩-overloading-🚀)
  * [3-1. 오버로딩이란 ??](#3-1-오버로딩이란)
  * [3-2. 가변인자와 오버로딩 (variable arguments and overloading)](#3-2-가변인자와-오버로딩-variable-arguments-and-overloading)

<br>
<br>
<br>

# 3. 오버로딩 (overloading) 🚀

<br><br>

## 3-1. 오버로딩이란 ??

<br>

같은 클래스 내에서 메서드 구별하는 법

한 클래스 내에 이미 같은 이름을 가진 메서드가 있더라고 `매개변수의 개수` 또는 `타입`이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다.

즉, 같은 이름의 메서드를 여러 개 정의할 수 있다는 것이다.

<br><br>

## 3-2. 가변인자와 오버로딩 (variable arguments and overloading)

<br>

기존 메서드는 매개변수 개수를 고정적으로만 지정이 가능 했다

하지만 가변인자의 등장으로

메서드의 매개변수를 동적으로 지정해줄 수 있다.

***가변인자 선언 : `타입... 변수명`***

밑에 예시를 통해서 사용법을 알아보자.

```java
class VariableArgumentsTest {
    public static void main(String[] args) {
        
        System.out.println(concentrate("-", "100", "200", "300"));

        String str = { "100", "200", "300" };
        System.out.println(concentrate("-", strArr));

        System.out.println(concentrate("-", new String[]{"100","200","300"}));
    }

    static String concentrate(String delim, String... args) {
        String result = "";

        for (String str : args) {
            result += str + delim;
        }

        return result;
    }
}
```

위 코드는 모두 다 똑같은 내용을 출력한다.

하지만 가변인자를 사용하면서 알아둬야 할 것이다.

**가변인자가 선언된 메서드를 호출할 때 마다 배열이 새로 생성된다.**

편리하지만, 비효율적이므로 필요할 때만 사용해야 한다.

또한 사용할 때 주의할 점으로 컴파일러가 인자와 가변인자를 구별할 수 있는지 생각해보아야 한다.

만약에 위의 VariableArgumentsTest에서 concentrate 메서드가 아래 코드처럼 매개변수를 가지고 있었으면 컴파일러는 어디까지가 가변인자인지 구분할 수가 없어 컴파일 에러가 뜬다.

```java
static String concentrate(String... args, String delim) {
    String result = "";

    for (String str : args) {
        result += str + delim;
    }

    return result;
}
```