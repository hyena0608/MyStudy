- [2. 변수와 메서드 🚀](#2-변수와-메서드-🚀)
  * [2-1. 선언위치에 따른 변수의 종류](#2-1-선언위치에-따른-변수의-종류)
    + [2-1-1. **인스턴스 변수 (instance variable)**](#2-1-1-인스턴스-변수-instance-variable)
    + [2-1-2. **클래스 변수 (class variable)**](#2-1-2-클래스-변수-class-variable)
    + [2-1-3. **지역변수 (local variable)**](#2-1-3-지역변수-local-variable)
  * [2-2. 메소드](#2-2-메소드)
    + [2-2-1. 메소드를 사용하는 이유 ??](#2-2-1-메소드를-사용하는-이유)
    + [2-2-2. 인자와 매개변수 (argument, parameter)](#2-2-2-인자와-매개변수-argument-parameter)
    + [2-2-3. 매개변수의 유효성 검사](#2-2-3-매개변수의-유효성-검사)
    + [2-2-4. 기본형 매개변수와 참조형 매개변수](#2-2-4-기본형-매개변수와-참조형-매개변수)
    + [2-2-5 클래스 메서드와 인스턴스 메서드 (static method, instance method)](#2-2-5-클래스-메서드와-인스턴스-메서드-static-method-instance-method)

<br>
<br>
<br>

# 2. 변수와 메서드 🚀 

<br><br>

## 2-1. 선언위치에 따른 변수의 종류

***`클래스변수`, `인스턴스변수`, `지역변수`*** 이 세 종류를 들어보지 않았는가?

이 변수들은 '변수의 선언된 위치'에 따라 달라진다.

이 세 종류를 또 두 종류로 나눌 수 있는데

***멤버변수 : 클래스변수, 인스턴스변수***

***멤버변수를 제외한 변수 : 지역변수***

로 나뉘어 진다.

코드로 간단하게 어떻게 선언되어지는지 알아보자.

```java
{
    // 클래스 영역

    int instanceVaraible;       // 인스턴스 변수
    static int classVariable;   // 클래스 변수(static 변수, 공유변수)

    void method()
    {
        // 메서드 영역
        int localVariable;      //  지역 변수
    }
}
```

위 코드를 보면 선언 위치 (영역)이 존재하고 그에 따라 변수의 생성시기도 다르다.

이를 표를 정리해보았다.

<table>
<tr>
<td>변수의 종류</td>
<td>선언위치</td>
<td>생성시기</td>
<tr>
<td>클래스 변수</td>
<td rowspan=2>클래스 영역</td>
<td>클래스가 메모리에 올라갈 때</td>
</tr>
<tr>
<td>인스턴스 변수</td>
<td>인스턴스가 생성되었을 때</td>
</tr>
<td>지역 변수</td>
<td>클래스 영역 이외의 영역<br>(메서드, 생성자, 초기화 블럭 내부)</td>
<td>변수 선어문이 수행되었을 때</td>
</table>

여기까지는 간단하게 알아보았지만 밑에서부터는

왜 선언 위치마다 변수가 다른지 ? 어떻게 생성하는지 알아보자.

<br>

### 2-1-1. **인스턴스 변수 (instance variable)**

<br>

인스턴스 변수의 값을 읽고 저장하기 위해서는 먼저 생성해야 한다.

인스턴스는 독립적인 저장 공간을 가진다. 이는 서로 다른 값을 가질 수 있다.

즉, 인스턴스 변수는 각각 고유한 상태를 유지해야하는 경우에 선언한다.

<br>

### 2-1-2. **클래스 변수 (class variable)**

<br>

클래스 변수를 선언 방법은 인스턴스 변수 앞에 `static`을 붙이면 된다.

클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)을 갖는다.

즉, 한 클래스의 모든 인스턴스가 공통 값을 가져야 할 때 클래스 변수로 선언한다.

클래스 변수는 생성하지 않고 바로 사용할 수 있으며 `클래스이름.클래스변수` 형식으로 사용한다.

클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때까지 살아 있다.

<br>

### 2-1-3. **지역변수 (local variable)**

<br>

메서드 내에 선언된다. 블럭 {}을 벗어나면 소멸된다.

<br><br>

이 세 종류를 토대로 예시 코드를 작성해 보았다.

언제 어디서 어떻게 사용되는지 알아보자.

```java
class Dog {
    String name;
    int age;
    static int legCount = 4;
}

class DogTest {
    public static void main(String[] args) {

        Dog d1 = new Dog();
        d1.name = "복팔치";
        d1.age = "7";

        System.out.println(d1.name + " " + d1.age 
                            + " " + d1.legCount); // 복팔치 7 4

        Dog d2 = new Dog();
        d2.name = "희몽구";
        d2.age = "10";

        System.out.println(d2.name + " " + d2.age
                            + " " + d2.legCount); // 희몽구 10 4

        Dog.legCount = 100;

        System.out.println(d1.name + " " + d1.age
                            + " " + d1.legCount); // 복팔치 7 100

        System.out.println(d2.name + " " + d2.age
                            + " " + d2.legCount); // 희몽구 10 100
        
    }
}
```

위에 예제를 보면 클래스 변수(static 변수)인 legCount는 Dog클래스의 인스턴스에서 생성하지 않고도 `Dog.legCount`로 사용할 수 있었다.

또한 Dog클래스의 인스턴스인 c1과 c2는 legCount를 클래스변수로 공유하고 있었기에 한쪽에서 legCount가 변경되면 다른 쪽도 반영된다. 정확히 얘기하자면 한쪽이 바뀌어서 다른 쪽이 바뀌는 것이 아니라 처음부터 공유하고 있었기에 한쪽이 바뀌는 것은 공유하고 있던 것이 바뀌는 것이라 다른 쪽은 이미 바꾸는 순간부터 바뀌었던 것이다.

즉, **인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다.**

<br><br><br>

여기까지 변수에 대해서 알아보았다.

다음은 변수와 관계가 깊은 메소드에 대해서 알아보자.

## 2-2. 메소드

메소드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.

그렇다면 이렇게 메소드를 사용하는 이유가 뭘까? 단지 편하기 때문만은 아닐 것이다.

조금 더 알아보자.

<br>

### 2-2-1. 메소드를 사용하는 이유 ??

<br>

1. **높은 재사용성 (reusability)**

    이미 메소드를 많이 사용해봤을 것이다.

    단지 호출함으로써 사용할 수 있는 편리함이 있다.

    <br>

2. **중복된 코드의 제거**

    반복되는 문장을 계속 반복하는 것은 정말 비효율적이다. 우리는 그 반복되는 문장들을 묶어서 하나의 메소드로 작성하여 한 문장으로 끝낼 수 있다.

    또한 메소드를 분리 시켜놓으면 수정해야할 코드의 양도 줄어들어 오류 발생 가능성도 줄어든다.

    메소드를 만들어 사용하는 것에 두려움을 없애고 잔뜩 사용해버리자

    밑에 중복된 코드를 메소드로 만드는 예시를 봐보자.

    먼저 중복되는 코드 예시이다.

    ```java
    public static void main(String[] args) {

        int[] arr = new int[10];

        for (int i = 0 ; i < 10; i++) 
            arr[i] = i;
        
        for (int i = 0; i < 10; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
        
        for (int i = 0; i < 10; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();

        for (int i = 0; i < 10; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();

        for (int i = 0; i < 10; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();

        // ...
    }
    ```
    이런 식으로 계속해서 반복될 때 메소드로 묶어보자

    ```java
    // 메소드 만들기
    static void printArr(int[] arr) {
        for(int i = 0; i < 10; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        
        int[] arr = new int[10];

        for (int i = 0 ; i < 10; i++) 
            arr[i] = i;

        printArr(arr); // 반복되는 코드 대신에 메소드를 출력해준다.
        printArr(arr);
        printArr(arr);
        printArr(arr);
        // ...
    }
    ```

    반복되는 코드가 아닌 메소드를 출력함으로써 훨씬 코드를 보기 수월해졌다.

    코드의 양도 적어졌고 만약 arr을 출력할때 띄어쓰기가 3칸이면 좋겠다고 변경사항이 발생하여도 손쉽게 메소드 부분만 손대어서 바꿀 수 있는 장점도 생겼다.
    
    <br>

3. **프로그램의 구조화**

    몇 줄 안되는 코드를 작성할 때는 상관이 없지만 큰 큐모의 프로그램일 경우에는 작업 단위를 나눠서 여러 개의 메소드를 만들어 프로그램의 구조를 단순화 시켜야 한다.

    위 2번에서 봤다시피 메소드를 만들면서 코드의 가독성이 좋아지고 그 만큼 프로그램의 전체 흐름을 파악하기에도 좋아진다. 메소드명이나 메소드를 작성할 때 여러가지 규칙이나 좋은 예시들이 있는데 이것은 후에 설명할 예정이다.

<br><br>

### 2-2-2. 인자와 매개변수 (argument, parameter)

<br>

***매개변수***는 메소드가 작업을 수행하는데 필요한 값들을 제공받이 위한 것이다.

메소드를 호출할 때 괄호`()`안에 지정해준 값들을 ***인자*** 또는 인수라고 한다.

***인자는 메서드가 호출되면서 매개변수에 대입이 되는 것이다.***

인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.

밑에서 인자와 매개변수를 구별해보자

```java
public static void main(String[] args) {
    // ...
    int result = add(3, 5); // 메소드 호출




    int add(int x, int y) {
        int result = x + y;
        return result;
    }
}
```

바로 정답은 아래 사진이다.

인자는 매개변수에 대입된다는 것을 기억하자 !

<img src="./images/인자매개변수.png" width=300 height=300 alt="인자와 매개변수"/>

<br><br><br>

메소드를 구현할 떄 우리는 항상 주의해야 하는 것이 있다.

매개변수의 값이 적절한 것인지 확인하는 것이다.

### 2-2-3. 매개변수의 유효성 검사

<br>

*'매개변수 타입에 맞게 알아서 잘 들어오겠지?'* 라는 생각을 한다면 바보다.

타입만 맞으면 어떤 값이든 들어올 수 있기 때문에 문제가 발생한다.

예를 들어보자.

0으로 나누는 것이 가능할까?

0으로 나누게 되면 무한이 되면서 오류가 발생하기 마련이다.

하지만 실제로 매개변수 y에 들어올 수 있기 때문에 문제가 발생할 수 있는 것이다.

그래서 우리는 항상 ***매개변수의 유효성 검사***를 해줘야 한다.

밑에는 유효성 검사가 들어간 코드 예시이다.

```java
float devide(int x, int y) {
    if (y == 0) {
        System.out.println("0으로 나눌 수 없습니다.");
        return 0;
    }
    return x / (float) y;
}
```

<br><br>

### 2-2-4. 기본형 매개변수와 참조형 매개변수 

<br>

기본형과 참조형을 불러오는 방식에서 차이가 나듯이 매개변수로서도 차이가 있다.

기본형일 때는 '기본형 값'이 복사되겠지만

참조형일 때는 '인스턴스의 주소'가 복사된다.

기본형의 값은 복사된 것이기에 단순히 저장된 값만을 얻는 것이지만

참조형은 주소를 알 수 있기 때문에 값을 읽기, 변경도 할 수 있다.

***기본형 : 변수의 값을 읽기만 할 수 있다.***

***참조형 : 변수의 값을 읽고 변경할 수 있다.***

밑에 예제를 통해 변수의 값을 변경하려 할 떄 기본형, 참조형을 비교해보자.

먼저 기본형 예시이다. 

만약 위의 말대로라면 실패한다.

```java
class Data {
    int x;
}

class PrimitiveTypeParamTest {
    public static void main(String[] args) {
        Data primitiveData = new Data();
        primitiveData.x = 10;
        System.out.println("main() : x = " + primitiveData.x);

        change(primitiveData.x);
        System.out.println("After change main() : x = " + primitiveData.x);
    }

    static void change(int x) {
        x = 1000;
        System.out.println("change() : x = " + x);
    }
}
```

```
기본형 출력 결과

main() : x = 10
change() : x = 1000
After change main() : x = 10
```

실제로 코드를 실행해 보았을 때 기본형이 매개변수(parameter)로 들어왔을 때는 값이 들어온 것이므로 마지막 change() 메소드를 호출하여도 실제 값은 변하지 않는다.

결국 위에서 말한 것과 같이 변화에 실패하였다.

그렇다면 참조형 매개변수일 경우에는 변화에 성공할 수 있을까 ??

밑에 코드에서 알아보자.

```java
class Data {
    int x;
}

class ReferenceTypeParamTest {
    public static void main(String[] args) {
        Data referenceData = new Data();
        referenceData.x = 10;
        System.out.println("main() : x = " + referenceData.x);

        change(referenceData.x);
        System.out.println("After change main() : x = " + referenceData.x);
    }

    static void change(Data data) {
        data.x = 1000;
        System.out.println("change() : x = " + data.x);
    }
}
```

```
참조형 출력 결과

main() : x = 10
change() : x = 1000
After change main() : x = 1000
```

당연하게도 참조형은 주소가 매개변수에 복사 된 것이라 실제 값을 변경할 수 있었다.

<br><br><br>

### 2-2-5 클래스 메서드와 인스턴스 메서드 (static method, instance method)

<br>

변수일 때 클래스변수와 같이 메서드 앞에 `static`이 붙어 있으면 클래스 메서드이다.

클래스 메서드도 클래서 변수처럼 객체 생성 없이 `클래스이름.메소드이름(매개변수)`와 같은 형식으로 호출이 가능하다.

인스턴스 메서드는 인터턴스 변수와 관련된 작업이며

인스턴스와 관계없는(인스턴스 변수, 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드 (static 메서드)라 정의한다.

조금만 더 깊게 들어가 본다면

1. **static 언제 붙이는데 ?**

    모든 인스턴스에서 같은 값이 유지되어야 하는 변수 -> 클래스 변수

    그러나 생성된 각 인스턴스가 서로 다른 값을 가져야 한다면 -> 인스턴스 변수

2. **클래스 변수 특징**

    인스턴스를 생성하지 않아도 사용할 수 있다.

    클래스 변수는 클래스가 메모리에 올라갈 때 이미 자동 생성되기 때문이다.

3. **클래스 메서드는 인스턴스 변수를 사용할 수 없다.**

    클래스 메서드는 인스턴스 생성 없이 호출 가능하므로 클래스 메서드 호출되었을 때 인스턴스가 존재하지 않을 수도 있기 때문이다.

    반면에 인스턴스 변수나 메서드에서는 static이 붙은 멤버들을 언제나 사용할 수 있다.

    인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 올라갔다는 것을 의미한다.

4. **메서드 내에서 인스턴스 변수를 사용하지 않으면, static을 붙이는 것을 고려한다.**

    인스턴스 변수를 필요로 하지않는 메서드에 static을 붙이자.

    - 메서드 호출 시간이 짧아지므로 성능이 향상되기 때문이다.

    - 인스턴스 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 더 필요하기 때문에 시간이 더 걸린다.