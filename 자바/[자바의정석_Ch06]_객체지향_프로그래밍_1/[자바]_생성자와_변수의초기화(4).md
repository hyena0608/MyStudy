- [1. 생성자 (Constructor) 🚀](#1-생성자-constructor-🚀)
  * [1-1. 생성자란 ??](#1-1-생성자란)
  * [1-2. 기본 생성자 (default constructor)](#1-2-기본-생성자-default-constructor)
  * [1-3. 생성자에서 다른 생성자 호출 - `this()`, `this`](#1-3-생성자에서-다른-생성자-호출---this-this)
  * [1-4. 생성자를 이용하여 인스턴스 복사하기](#1-4-생성자를-이용하여-인스턴스-복사하기)
- [2. 변수의 초기화 🚀](#2-변수의-초기화-🚀)
    + [2-1. 변수의 초기화](#2-1-변수의-초기화)
    + [2-2. 명시적 초기화 란?? (explicit initialization)](#2-2-명시적-초기화-란-explicit-initialization)
    + [2-3. 초기화 블럭 (initialization block)](#2-3-초기화-블럭-initialization-block)
    + [2-4. 멤버변수의 초기화 시기와 순서 (+ 초기화 블럭)](#2-4-멤버변수의-초기화-시기와-순서--초기화-블럭)

<br>
<br>
<br>

# 1. 생성자 (Constructor) 🚀

<br>
<br>

생성자는 자바를 사용하는 개발자라면 인스턴스를 생성하기 위해 쓰지 않을 수가 없을 존재이다.

하지만 과연 생성자가 인스턴스를 생성하는 걸까?

생성자에 대해서 더 알아보자

## 1-1. 생성자란 ??

<br>

***생성자 : 인스턴스 생성 시 호출되는 '인스턴스 초기화 메서드'***

<br>

생성자가 메서드라고? 그럼 메서드랑 똑같은 걸까??

*생성자가 메서드가 맞다 !! 👍*

생성자도 클래스 내에서 선언되고, 주도도 메서드와 비슷하지만 **리턴값이 없다.**

또한 생성자의 이름은 클래스의 이름과 같아야 한다.

한가지 더 얘기하자면 오버로딩도 가능하다 !

밑에 있는 코드로 어떤 거를 얘기하는 건지 알아보자.

```java
클래스이름(타입 변수명, 타입 변수명, ...) {
    // 인스턴스 생성 시 수행할 코드 (초기화.. 등)
}
```

```java
class Dog {
    String name;
    int age;

    Dog() {
        // 매개변수가 없는 생성자
    }

    Dog(String name, int age) {
        // 매개변수가 있는 생성자
        this.name = name;
        this.age = age;
    }
}
```

밑에서는 생성자를 이용하는 법이다.

생성자는 인스턴스 초기화하는 메서드이고 실제로 인스턴스를 생성하는 것은 `연산자 new`인 것에 주의하자.

```java
Dog d1 = new Dog();
Dog d2 = new Dog("복팔치", 7);
```

Dog클래스의 인스턴스 생성 과정을 보면

1. `연산자 new`에 의해서 메모리 힙 영역에 Dog클래스의 인스턴스가 생성된다.
2. 생성자 Dog()가 호출되어 수행된다.
3. `연산자 new`의 결과로, 생성된 Dog 인스턴스의 주소가 반환되어 참조변수 `d1`에 저장된다.

결과적으로 new로 인스턴스를 생성하여 반환된 주소를 참조변수 d1에 저장하는 것이다.

<br><br><br>

근데 나는 생성자를 정의하지 않고도 Dog클래스의 인스턴스를 생성한 적이 있는데..?

아래에서 왜 그런지 알아보자.

## 1-2. 기본 생성자 (default constructor)

<br>

이유는 컴파일러가 제공하는 '기본 생성자' 때문이다.

컴파일 할 때, 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가하여 컴파일 해준다.

아래 코드는 생성자가 정의되지 않은 예시이다.

```java
class Dog {
    String name;
    int age;

    // 컴파일러가 자동으로 기본 생성자를 만들어줌.
}

class ConstructorTest {
    public static void main(String[] args) {
        Dog d1 = new Dog(); // OK
    }
}
```

<br>
<br>
<br>

## 1-3. 생성자에서 다른 생성자 호출 - `this()`, `this`

***생성자 간에도 서로 호출이 가능하다 !! (단, 두 조건이 있다.)***

1. 생성자의 이름으로 클래스이름 대신 `this`를 사용한다.
2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 **첫 줄**에서만 호출이 가능하다.

예시 코드를 보면서 규칙이 어떻게 적용됐는지 봐보자.

```java
class Dog {
    String name;
    int age;

    Dog() {
        this("복팔치", 7);
    }

    Dog(String name) {
        this(name, 7);
    }

    Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class DogTest {
    public static void main(String[] args) {
        Dog d1 = new Dog();
        Dog d2 = new Dog("희몽구");

        System.out.println(d1.name + " " + d1.age);
        System.out.println(d2.name + " " + d2.age);
    }
}
```

밑에 출력을 보면 생성자 간의 호출에 생성자의 이름 대신 `this`를 사용해야 함을 알 수 있다.

```
DogTest 출력 :

복팔치 7
희몽구 7
```

<br>
<br>
<br>

## 1-4. 생성자를 이용하여 인스턴스 복사하기

<br>

바로 코드로 알아보자.

```java
class Dog {
    String name;
    int age;

    Dog(String name, String age) {
        this.name = name;
        this.age = age;
    }

    Dog(Dog d) {
        this(d.name, d.age);
    }
}

class DogTest {
    Dog d = new Dog("복팔치", 7);
    Dog myDog = new Dog(d);

    System.out.println(myDog.name + " " + myDog.age);
}
```
```
DogTest 출력 :

복팔치 7
```

생성자는 중요하다 !!

생성자를 잘 활용하면 더 간결하고 직관적인 코드를 만들 수 있음에 주의하자 !

<br>
<br>
<br>

# 2. 변수의 초기화 🚀

***변수의 초기화 : 변수를 선언하고 처음으로 값을 저장하는 것***

변수의 초기화는 선택적이기도 필수적이기도 하다.

가능하면 우리는 선언과 동시에 초기화를 하는게 좋다.

<br>
<br>

### 2-1. 변수의 초기화

<br>

**멤버변수(클래스변수, 인스턴스변수)** : 초기화하지 않아도 자료형에 맞게 기본값으로 자동 초기화, 때문에 초기화가 *선택적*이다.

**지역변수** : 자동적으로 초기화되지 않으므로, 초기화 되진 않은 생테에서 다른 변수를 초기화하려 하면 컴파일 에러가 난다, 때문에 초기화가 *필수적*이다.

밑에 예시를 봐보자.

```java
class InitTest {
    int x;      // 인스턴스 변수
    int y = x;  // 인스턴스 변수

    void methodTest() {
        int i;
        int j = i; 에러. 지역변수를 초기화하지 않고 사용
    }
}
```

<br>
<br>

### 2-2. 명시적 초기화 란?? (explicit initialization)

<br>

***명시적 초기화 : 선언과 동시에 초기화하는 것***

명시적 초기화 예시 코드를 보자.

```java
class Dog {
    String name = "복팔치"; // 기본형 변수의 초기화
    Food food = new Food(); // 참조형 변수의 초기화
}
```

하지만 보다 복잡한 초기화 작업이 필요할 때는

***초기화 블럭*** 또는 ***생성자***를 사용해야 한다.

생성자는 위에서 배웠지만 초기화 블럭은 배우지 않았다.

초기화 블럭에 대해서 알아보자

<br>
<br>

### 2-3. 초기화 블럭 (initialization block)

<br>

초기화 블럭은 두 가지 종류로 나뉘어진다.

1. ***클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용된다.***

2. ***인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용된다.***

초기화 블럭은 단순히 클래스 내에 블럭 `{}`를 만들고 그 안에 코드를 작성하면 된다.

클래스 초기화 블럭은 인스턴스 초기화 블럭 앞에 `static`을 덧붙이면 된다.

코드로 기본 구조를 봐보자.

```java
class InitBlock {
    static { /* 클래스 초기화 블럭 */ }

    { /* 인스턴스 초기화 블럭 */ }

    // ...
}
```

이러한 초기화 블럭은 어떤 식으로 그리고 왜 사용할까?

일단 초기화 블럭을 쓰면 코드의 중복 제거, 재사용성이 있다. 결국 객체지향 프로그래밍의 이점 중 하나이다.

아래 코드를 봐보자.

`count++;` 와 `dogNo = count;`가 중복됐음을 알 수 있다.

```java
Dog() {
    count++;
    dogNo = count;
    name = "복팔치";
    age = 7;
}

Dog(String name, int age) {
    count++;
    dogNo = count;
    this.name = name;
    this.age = age;
}
```

초기화 블럭은 이런 중복 코드를 제거해줄 수 있다.

아래 코드는 초기화 블럭을 사용한 코드이며 위 코드와 똑같은 내용을 갖고 있다.

```java
{
    // 인스턴스 초기화 블럭
    count++;
    dogNo = count;
}

Dog() {
    name = "복팔치";
    age = 7;    
}

Dog(String name, int age) {
    this.name = name;
    this.age = age;
}
```

또한 클래스변수와 인스턴스변수의 메모리 로딩이 다르듯이

static을 사용하는 클래스 초기화 블럭과 인스턴스 초기화 블럭도 다르다.

**클래스 초기화 블럭**은 static이 붙으므로 JVM이 클래스를 읽어 메모리에 올라갈 때 실행

**인스턴스 초기화 블럭**은 인스턴스를 생성할 때 실행되어진다.

좀 더 자세히 알아보자.

<br>
<br>

### 2-4. 멤버변수의 초기화 시기와 순서 (+ 초기화 블럭)

***클래스변수의 초기화 시점*** : 클래스가 처음 로딩될 때 한번 초기화

***인스턴스변수의 초기화 시점*** : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화

***클래스변수의 초기화 순서*** : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭

***인스턴스변수의 초기화 순서*** : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭  -> 생성자


코드를 보며 비교하자.

```java
class InitTest {
    static int classVariable = 1;
    int instanceVariable = 1;

    static { 
        classVariable = 2;
    }

    {
        instanceVariable = 2;
    }

    InitTest() {
        instanceVariable = 3;
    }
}
```

먼저 클래스가 로딩되면서 static로 메모리에 올라가게 된다.

즉 `classVariable`이 `0`이었다가 클래스변수가 있어 명시적 초기화가 되면서 `1`이 된다.

후에 `static {}`인 클래스 초기화 블럭이 실행되면서 `classVariable`이 `2`가 된다.
 
 `static`이 끝난후 이제 인스턴스가 생성되면서 `instanceVariable`이 메모리 힙영역에 저장된다. 이 때 기본값이 `0`으로 저장이 되어있다.

 명시적 초기화로 인해서 `instanceVariable`이 `1`이 되고 
 
 인스턴스 초기화 블럭이 수행되며 `instanceVariable`이 `2`가 된다.

 다음에 생성자가 실행이 되면서 `instanceVariable`은 `3`이 된다.

 이 때 `classVariable`은 여전히 변함없이 `2`이다.
