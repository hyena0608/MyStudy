# 소켓을 이용한 채팅 프로그램 🚀
<br>

자세한 내용은 아래 노션 페이지에 정리돼있습니다.

##  [🔗 소켓을 이용한 채팅 프로그램 정리 노션 바로가기](https://hyena.oopy.io/b612f306-99f8-4a73-a313-d94f2cdd8f9c)


<br>

- [소켓을 이용한 채팅 프로그램 🚀](#소켓을-이용한-채팅-프로그램-🚀)
  * [🤷 1) 왜 굳이 채팅 프로그램을 구현했어요 ?](#💁‍♂️-1-3-uml-클래스-다이어그램의-활용)
    + [💁‍♂️ 1-1) 쓰레드 (Thread)](#💁‍♂️-1-1-쓰레드-thread)
    + [💁‍♂️ 1-2) 객체 지향 프로그래밍](#💁‍♂️-1-2-객체-지향-프로그래밍)
    + [💁‍♂️ 1-3) UML (클래스 다이어그램)의 활용](#💁‍♂️-1-3-uml-클래스-다이어그램의-활용)




<br>
<br>
<br>
<br>

- 채팅 프로그램을 구현하기 위해서는 기본적으로 소켓(socket)이라는 것을 사용하게 됩니다.

- 이 때 소켓은 프로세스(process) 간의 통신을 위해서 필요하며 

    프로토콜(protocol)에 따라 다른 종류의 소켓을 구현하여 제공합니다.

<br>


## 🤷 1) 왜 굳이 채팅 프로그램을 구현했어요 ?

<br>

저는 소켓을 이용한 채팅 프로그램 구현 프로젝트를 진행하면서

객체지향의 전체적인 맥락을 느낄 수 있었습니다. 

아래와 같이 쓰레드와 객체지향, 파일 I/O, UML 설계까지 경험할 수 있었죠.

<br>

### 💁‍♂️ 1-1) **쓰레드 (Thread)**
이러한 소켓으로 채팅 프로그램을 구현하려면 양방향 통신이 기본이 됩니다.

채팅은 한 번만 주고 받는 쪽지가 아니므로 계속해서 메시지 송수신 기능이 돌아가야 합니다.

이 때 첫 번째로 **쓰레드(Thread)** 를 사용하게 됩니다.

멀티쓰레드(multi thread)를 사용하면서

현 '소켓을 이용한 채팅 프로그램' 에서는 다음과 같은 경험을 얻게 되었습니다.
1. 여러 클라이언트 관리 중 생기는 교착상태(deadlock) 이슈 해결
1. 한 프로세스 내에서 콘솔과 소켓에서 송수신 이슈 해결
1. 파일 송수신 시 기존 채팅 멈춤 이슈 해결

<br>
<br>
<br>

### 💁‍♂️ 1-2) **객체 지향 프로그래밍**
채팅 프로그램을 구현하게 되면 계속해서 기능이 추가되게 됩니다.

기능 추가에 있어서 객체 지향적인 구현이지 않을 시에 큰 곤란을 겪을 수 있습니다.

때문에 다음과 같은 학습과 함께 '소켓을 이용한 채팅 프로그램" 프로젝트를 진행하였습니다.

1. 다형성의 활용 (+ 정적 팩토리 패턴)
1. 책임과 역할 분리를 위한 클래스, 메서드 분리
1. forEach문을 활용한 클라이언트 검색

<br>
<br>
<br>

### 💁‍♂️ 1-3) **UML (클래스 다이어그램)의 활용**

프로젝트를 구현하면서 현재 설계가 옳바른지 확인하기 위해 

직접 UML (클래스 다이어그램)을 수정해나아가면서 진행하였습니다.

총 8회 정도 설계도(메인 채팅 서버, 클라이언트 서버)를 갈아 엎으며 완성도를 높여나갔습니다. 